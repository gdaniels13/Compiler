

#include <iostream>
using namespace std;

struct E{}; //int, type*, location, value
int lookup (E*);
int getReg();
void setLocation(E*);

void ProLog()
{
   cout << "main: "   //check slides
}

E * addE(E * a, E * b)
{
   int aLoc = lookup(a);
   int bLoc = lookup(b);
   int resultLocation = getReg();
   cout << "add $" << resultLocation 
     << ", $" << aLoc
     << ", $" << bLoc << endl;
  return new E(resultLocation);
}

E * multE(E * a, E * b)
{
   int aLoc = lookup(a);
   int bLoc = lookup(b);
   int resultLocation = getReg();
   cout << "mult $" << resultLocation 
     << ", $" << aLoc
     << ", $" << bLoc << endl;
  return new E(resultLocation);
}

E * load(std::string name)
{
   auto offset = lookup(name);
   int resultLocation = getReg();
   cout << "lw $" << resultLocation
     << ", $" << offset.second
     << "(" << offset.first
     << ")" << endl;
}

void Write(EList *)
{
     for(; cur != nullptr; cur = cur->next)
     {
          cout << "mv $" << ", $a0" << endl;
          cout << "syscall 6" << endl;
     }
}

expression and read and write 



Bison

P      : Pheader EList
        ;

Pheader : {Prolog();}
             ;

EList : E EList
         |
         ;

E : E + E { $$ = AddE($1, $3);}
   | E  * E {$$ = multE($1, $3);}
   | ident {$$ = load($1)};
   ;

Read : EList
        ;

Write : EList
        ;






        Expression * Table::makeExpression(Expression * a, symbols sym, Expression * b)
{
  std::cout<<"MAKING EXPRESSION\n";
  Expression * E;

  if(a->m_type == UNKNOWN)
  {
    if(sym == NOT)
    {
      int size = (int)atoi(b->m_value.c_str());
      size = ~size;
      return new Expression(std::to_string(size),b->m_type);
    }
    else if(sym == UNARY)
    {
      int size = (int)atoi(b->m_value.c_str());
      size = -size;
      return new Expression(std::to_string(size),b->m_type);
    }
    else
    {
      std::cout << "CONST ERRORS UNKNOWN SYMBOL" << std::endl;
      exit(-1);
    }
  }
  else if(a->m_type != b->m_type)
  {
    std::cout << "CONST ERRORS TYPE MISMATCH" << std::endl;
    exit(-1);
  }
  if(a->m_type == INT || a->m_type == CHAR)
  {
    switch(sym)
    {
      case OR:
      {
        int size = (int)atoi(a->m_value.c_str()) ||  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case AND:
      {
        int size = (int)atoi(a->m_value.c_str()) &&  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case NOT_EQUAL:
      {
        int size = (int)atoi(a->m_value.c_str()) !=  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case EQUAL:
      {
        int size = (int)atoi(a->m_value.c_str()) ==  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case LESS_EQUAL:
      {
        int size = (int)atoi(a->m_value.c_str()) <=  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case GREAT:
      {
        int size = (int)atoi(a->m_value.c_str()) >  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case GREAT_EQUAL:
      {
        int size = (int)atoi(a->m_value.c_str()) >=  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case LESS:
      {
        int size = (int)atoi(a->m_value.c_str()) <  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case ADD:
      {
        int size = (int)atoi(a->m_value.c_str()) +  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case SUB:
      {
        int size = (int)atoi(a->m_value.c_str()) -  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case DIV:
      {
        int size = (int)atoi(a->m_value.c_str()) /  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case MOD:
      {
        int size = (int)atoi(a->m_value.c_str()) %  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      case MULT:
      {
        int size = (int)atoi(a->m_value.c_str()) *  (int)atoi(b->m_value.c_str());
        return new Expression(std::to_string(size), a->m_type);
      }
      default:
        std::cout << "Expression ERRORS MAKE Expression" << std::endl;
        exit(-1);
    }
  }
  else if(a->m_type == STRING)
  {
    switch(sym)
    {
      case OR:
      {
        int size = a->m_value.length() || a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case AND:
      {
        int size = a->m_value.length() && a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case NOT_EQUAL:
      {
        int size = a->m_value.length() != a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case EQUAL:
      {
        int size = a->m_value.length() == a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case LESS_EQUAL:
      {
        int size = a->m_value.length() <= a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case GREAT:
      {
        int size = a->m_value.length() > a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case GREAT_EQUAL:
      {
        int size = a->m_value.length() >= a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case LESS:
      {
        int size = a->m_value.length() < a->m_value.length();
        return new Expression(std::to_string(size), a->m_type);
      }
      case ADD:
      {
        std::string size = a->m_value + a->m_value;
        return new Expression(size, a->m_type);
      }
      default:
        std::cout << "Expression ERRORS MAKE CONST" << std::endl;
        exit(-1);
    }
  }
  else
  {
    std::cout<<"blah blah blah\n";
    E = new Expression("just for kicks", STRING);
  }

  std::cout << a->m_value << " " << sym << " " << b->m_value << std::endl;
  return E;
}